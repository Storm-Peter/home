<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <style>
    html, body { height: 100%; margin: 0; background: #000; color: #bbb; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    #game { position: fixed; inset: 0; display: block; width: 100%; height: 100%; }
    .ui { position: fixed; top: 8px; left: 8px; font-size: 14px; user-select: none; }
    .badge { background: rgba(255,255,255,.06); padding: 4px 8px; border-radius: 8px; margin-right: 8px; }
    #overlay { position: fixed; inset: 0; display: flex; align-items: center; justify-content: center; color: #ddd; background: rgba(0,0,0,.6); cursor: pointer; }
    #touch { position: fixed; inset: 0; pointer-events: none; }
    button.touch { pointer-events: auto; position: absolute; width: 64px; height: 64px; border-radius: 50%; background: rgba(255,255,255,.08); border: 1px solid rgba(255,255,255,.2); color: #bbb; }
    button.touch:active { background: rgba(255,255,255,.2); }
    #btnLeft{ left: 12px; bottom: 24px; }
    #btnRight{ left: 92px; bottom: 24px; }
    #btnThrust{ right: 92px; bottom: 24px; }
    #btnFire{ right: 12px; bottom: 24px; }
    #btnHyper{ left: calc(50% - 32px); bottom: 24px; }
    @media (pointer: fine) { #touch { display: none; } }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <div class="ui" id="hud"></div>
  <div id="overlay">Click or press any key to start</div>
  <div id="touch" aria-hidden="true">
    <button id="btnLeft" class="touch" aria-label="Rotate Left">⟲</button>
    <button id="btnRight" class="touch" aria-label="Rotate Right">⟳</button>
    <button id="btnThrust" class="touch" aria-label="Thrust">▲</button>
    <button id="btnFire" class="touch" aria-label="Fire">●</button>
    <button id="btnHyper" class="touch" aria-label="Hyperspace">✦</button>
  </div>
  <script>
  (() => {
    'use strict';
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    function resize() {
      const dpr = window.devicePixelRatio || 1;
      const w = Math.floor(window.innerWidth);
      const h = Math.floor(window.innerHeight);
      canvas.style.width = w + 'px';
      canvas.style.height = h + 'px';
      canvas.width = Math.floor(w * dpr);
      canvas.height = Math.floor(h * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    window.addEventListener('resize', resize); resize();

    const hud = document.getElementById('hud');
    const overlay = document.getElementById('overlay');

    // --- Audio (Web Audio API, no assets) ---
    let audio, sfx, audioReady = false, muted = false;
    function initAudio() {
      if (audio) return;
      const AC = window.AudioContext || window.webkitAudioContext;
      audio = new AC();
      sfx = { master: audio.createGain(), thrust: audio.createGain() };
      sfx.master.gain.value = 0.22;
      sfx.master.connect(audio.destination);
      sfx.thrust.gain.value = 0;
      sfx.thrust.connect(sfx.master);
      // continuous thrust osc (gentler: triangle + lowpass)
      const thrOsc = audio.createOscillator();
      thrOsc.type = 'triangle';
      thrOsc.frequency.value = 90;
      const thrFilt = audio.createBiquadFilter();
      thrFilt.type = 'lowpass';
      thrFilt.frequency.value = 240;
      thrFilt.Q.value = 0.7;
      thrOsc.connect(thrFilt);
      thrFilt.connect(sfx.thrust);
      thrOsc.start();
      audioReady = true;
    }
    function playBeep({ freq = 440, dur = 0.07, type = 'square', gain = 0.2 }) {
      if (!audioReady || muted) return;
      const o = audio.createOscillator();
      const g = audio.createGain();
      o.type = type; o.frequency.value = freq;
      g.gain.value = gain;
      o.connect(g); g.connect(sfx.master);
      const t = audio.currentTime;
      g.gain.setValueAtTime(gain, t);
      g.gain.exponentialRampToValueAtTime(0.001, t + dur);
      o.start(t); o.stop(t + dur + 0.02);
    }
    function explosion() {
      if (!audioReady || muted) return;
      const t0 = audio.currentTime;
      for (let i = 0; i < 5; i++) {
        const o = audio.createOscillator();
        const g = audio.createGain();
        o.type = 'triangle';
        o.frequency.setValueAtTime(80 + Math.random() * 160, t0);
        o.frequency.exponentialRampToValueAtTime(30 + Math.random() * 50, t0 + 0.35);
        g.gain.value = 0.25; g.gain.exponentialRampToValueAtTime(0.001, t0 + 0.35);
        o.connect(g); g.connect(sfx.master);
        o.start(t0 + i * 0.005); o.stop(t0 + 0.4);
      }
    }
    function hyperspaceSound() {
      if (!audioReady || muted) return;
      const t0 = audio.currentTime;
      const o = audio.createOscillator(); const g = audio.createGain();
      o.type = 'sine'; o.frequency.setValueAtTime(220, t0);
      o.frequency.exponentialRampToValueAtTime(660, t0 + 0.25);
      g.gain.value = 0.2; g.gain.exponentialRampToValueAtTime(0.001, t0 + 0.3);
      o.connect(g); g.connect(sfx.master); o.start(t0); o.stop(t0 + 0.32);
    }
    function setThrustVolume(v) { if (!audioReady) return; sfx.thrust.gain.cancelScheduledValues(audio.currentTime); sfx.thrust.gain.setTargetAtTime(muted ? 0 : v * 0.25, audio.currentTime, 0.02); }

    // --- Input ---
    let keys = { left: false, right: false, up: false, fire: false, hyper: false };
    let touchState = { left: false, right: false, up: false, fire: false, hyper: false };

    function bindTouch(id, prop) {
      const el = document.getElementById(id);
      const on = (e) => { e.preventDefault(); touchState[prop] = true; };
      const off = (e) => { e.preventDefault(); touchState[prop] = false; };
      el.addEventListener('touchstart', on, { passive: false });
      el.addEventListener('touchend', off, { passive: false });
      el.addEventListener('mousedown', on);
      window.addEventListener('mouseup', off);
    }
    bindTouch('btnLeft', 'left');
    bindTouch('btnRight', 'right');
    bindTouch('btnThrust', 'up');
    bindTouch('btnFire', 'fire');
    bindTouch('btnHyper', 'hyper');

    window.addEventListener('keydown', (e) => {
      if (e.repeat) return;
      if (overlay) startGame(); // any key starts
      switch (e.code) {
        case 'ArrowLeft': keys.left = true; break;
        case 'ArrowRight': keys.right = true; break;
        case 'ArrowUp': keys.up = true; break;
        case 'Space': keys.fire = true; break;
        case 'ShiftLeft': case 'ShiftRight': keys.hyper = true; break;
        case 'KeyP': togglePause(); break;
        case 'KeyM': muted = !muted; break;
      }
    });
    window.addEventListener('keyup', (e) => {
      switch (e.code) {
        case 'ArrowLeft': keys.left = false; break;
        case 'ArrowRight': keys.right = false; break;
        case 'ArrowUp': keys.up = false; break;
        case 'Space': keys.fire = false; break;
        case 'ShiftLeft': case 'ShiftRight': keys.hyper = false; break;
      }
    });

    canvas.addEventListener('pointerdown', () => { startGame(); }, { passive: true });
    overlay.addEventListener('click', () => { startGame(); });

    let running = false, paused = false;
    function startGame() {
      if (running) return;
      overlay.style.display = 'none';
      initAudio(); audio.resume && audio.resume();
      running = true; lastTime = performance.now(); loop();
    }

    document.addEventListener('visibilitychange', () => { if (document.hidden) paused = true; });

    const W = () => canvas.width / (window.devicePixelRatio || 1);
    const H = () => canvas.height / (window.devicePixelRatio || 1);

    function rnd(a, b) { return a + Math.random() * (b - a); }
    function wrap(obj) {
      const w = W(), h = H(), r = obj.r;
      if (obj.x < -r) obj.x += w + 2 * r;
      if (obj.x > w + r) obj.x -= w + 2 * r;
      if (obj.y < -r) obj.y += h + 2 * r;
      if (obj.y > h + r) obj.y -= h + 2 * r;
    }
    function dist2(a, b) { const dx = a.x - b.x, dy = a.y - b.y; return dx * dx + dy * dy; }

    class Ship {
      constructor() { this.reset(); }
      reset() { this.x = W() / 2; this.y = H() / 2; this.vx = 0; this.vy = 0; this.a = -Math.PI / 2; this.r = 14; this.cool = 0; this.hyperCool = 0; this.inv = 2.0; this.dead = false; }
      update(dt) {
        const rotSpeed = 3.5;  // rad/s
        const thrust = 220;    // px/s^2
        const maxSpeed = 420;
        if (keys.left || touchState.left) this.a -= rotSpeed * dt;
        if (keys.right || touchState.right) this.a += rotSpeed * dt;
        const applyingThrust = (keys.up || touchState.up) && !this.dead;
        if (applyingThrust) { this.vx += Math.cos(this.a) * thrust * dt; this.vy += Math.sin(this.a) * thrust * dt; }
        // friction
        this.vx *= (1 - 0.5 * dt); this.vy *= (1 - 0.5 * dt);
        // clamp
        const sp = Math.hypot(this.vx, this.vy), max = maxSpeed; if (sp > max) { this.vx *= max / sp; this.vy *= max / sp; }
        this.x += this.vx * dt; this.y += this.vy * dt; wrap(this);
        this.cool = Math.max(0, this.cool - dt); this.hyperCool = Math.max(0, this.hyperCool - dt); this.inv = Math.max(0, this.inv - dt);
        setThrustVolume(applyingThrust && !this.dead ? 1 : 0);
        if ((keys.hyper || touchState.hyper) && this.hyperCool <= 0 && !this.dead) { this.hyperCool = 3.0; hyperspaceSound(); this.x = rnd(0, W()); this.y = rnd(0, H()); }
      }
      fire() {
        if (this.cool > 0 || this.dead) return null;
        this.cool = 0.18;
        const speed = 740;
        const bx = this.x + Math.cos(this.a) * this.r;
        const by = this.y + Math.sin(this.a) * this.r;
        const bvx = this.vx + Math.cos(this.a) * speed;
        const bvy = this.vy + Math.sin(this.a) * speed;
        playBeep({ freq: 660, dur: 0.05, type: 'square', gain: 0.15 });
        return new Bullet(bx, by, bvx, bvy);
      }
      draw(ctx) {
        ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.a);
        ctx.lineWidth = 2;
        ctx.strokeStyle = this.inv > 0 && (Math.floor(this.inv * 8) % 2 === 0) ? '#555' : '#bbb';
        ctx.beginPath();
        ctx.moveTo(this.r, 0);
        ctx.lineTo(-this.r * 0.8, this.r * 0.6);
        ctx.lineTo(-this.r * 0.4, 0);
        ctx.lineTo(-this.r * 0.8, -this.r * 0.6);
        ctx.closePath();
        ctx.stroke();
        // thrust flame
        if (keys.up || touchState.up) {
          ctx.beginPath();
          ctx.moveTo(-this.r * 0.8, 0);
          ctx.lineTo(-this.r * 1.2, 0);
          ctx.strokeStyle = '#888';
          ctx.stroke();
        }
        ctx.restore();
      }
    }

    class Bullet {
      constructor(x, y, vx, vy) { this.x = x; this.y = y; this.vx = vx; this.vy = vy; this.life = 1.8; this.r = 3.5; }
      update(dt) { this.x += this.vx * dt; this.y += this.vy * dt; wrap(this); this.life -= dt; }
      draw(ctx) {
        const ang = Math.atan2(this.vy, this.vx);
        const len = Math.min(28, Math.hypot(this.vx, this.vy) * 0.02);
        ctx.save();
        ctx.shadowColor = '#fff';
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.moveTo(this.x - Math.cos(ang) * len, this.y - Math.sin(ang) * len);
        ctx.lineTo(this.x, this.y);
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.shadowBlur = 0;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
        ctx.fillStyle = '#fff';
        ctx.fill();
        ctx.restore();
      }
    }

    function makeRockShape(scale) {
      const pts = []; const verts = 10;
      for (let i = 0; i < verts; i++) { const ang = i / verts * Math.PI * 2; const rad = scale * (0.7 + Math.random() * 0.6); pts.push({ x: Math.cos(ang) * rad, y: Math.sin(ang) * rad }); }
      return pts;
    }
    class Ast {
      constructor(x, y, size = 3) {
        this.x = x; this.y = y;
        const ang = rnd(0, Math.PI * 2); const spd = rnd(20, 70) * (4 - size); this.vx = Math.cos(ang) * spd; this.vy = Math.sin(ang) * spd;
        this.a = rnd(0, Math.PI * 2); this.spin = rnd(-0.6, 0.6);
        this.size = size; const base = size === 3 ? 46 : size === 2 ? 28 : 18; this.r = base; this.shape = makeRockShape(this.r);
      }
      update(dt) { this.x += this.vx * dt; this.y += this.vy * dt; this.a += this.spin * dt; wrap(this); }
      draw(ctx) { ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.a); ctx.beginPath(); const pts = this.shape; ctx.moveTo(pts[0].x, pts[0].y); for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y); ctx.closePath(); ctx.strokeStyle = '#aaa'; ctx.lineWidth = 2; ctx.stroke(); ctx.restore(); }
      split() { if (this.size > 1) { return [new Ast(this.x, this.y, this.size - 1), new Ast(this.x, this.y, this.size - 1)]; } return []; }
    }

    class CometLink {
      constructor(label, url) {
        // spawn at edge, fly inward
        const side = Math.floor(Math.random() * 4); const w = W(), h = H();
        if (side === 0) { this.x = -30; this.y = rnd(0, h); }
        else if (side === 1) { this.x = w + 30; this.y = rnd(0, h); }
        else if (side === 2) { this.x = rnd(0, w); this.y = -30; }
        else { this.x = rnd(0, w); this.y = h + 30; }
        const cx = w / 2, cy = h / 2;
        const ang = Math.atan2(cy - this.y, cx - this.x) + rnd(-0.5, 0.5);
        const spd = rnd(60, 110); this.vx = Math.cos(ang) * spd; this.vy = Math.sin(ang) * spd;
        this.a = rnd(0, Math.PI * 2); this.spin = rnd(-0.5, 0.5);
        this.r = 56; this.body = makeRockShape(this.r * 0.9);
        this.tail = Array.from({ length: 10 }, () => ({ x: this.x, y: this.y }));
        this.label = label; this.url = url; this.triggered = false;
      }
      update(dt) { this.x += this.vx * dt; this.y += this.vy * dt; this.a += this.spin * dt; wrap(this); this.tail.unshift({ x: this.x, y: this.y }); if (this.tail.length > 12) this.tail.pop(); }
      draw(ctx) {
        // tail
        ctx.save(); ctx.strokeStyle = '#666'; ctx.lineWidth = 1.5; ctx.beginPath(); for (let i = 0; i < this.tail.length; i++) { const p = this.tail[i]; if (i === 0) ctx.moveTo(p.x, p.y); else ctx.lineTo(p.x, p.y); } ctx.stroke(); ctx.restore();
        // body
        ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.a); ctx.beginPath(); const pts = this.body; ctx.moveTo(pts[0].x, pts[0].y); for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y); ctx.closePath(); ctx.strokeStyle = '#ddd'; ctx.lineWidth = 2; ctx.stroke(); ctx.restore();
        // label (upright)
        ctx.save(); ctx.fillStyle = '#bbb'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.font = '12px ui-monospace, monospace'; ctx.fillText(this.label, this.x, this.y); ctx.restore();
      }
      hit() { if (this.triggered) return; this.triggered = true; triggerLink(this.url); }
    }

    class Particle { constructor(x, y) { this.x = x; this.y = y; const ang = rnd(0, Math.PI * 2), sp = rnd(40, 200); this.vx = Math.cos(ang) * sp; this.vy = Math.sin(ang) * sp; this.life = rnd(0.3, 0.7); } update(dt) { this.x += this.vx * dt; this.y += this.vy * dt; this.life -= dt; } draw(ctx) { ctx.globalAlpha = Math.max(0, this.life / 0.7); ctx.fillStyle = '#999'; ctx.fillRect(this.x, this.y, 2, 2); ctx.globalAlpha = 1; } }

    let ship, bullets = [], asts = [], comets = [], parts = [];
    let score = 0, lives = 3, wave = 1, extraAt = 10000, linkCooldown = 0;
    const MAX_BULLETS = 4;

    function spawnWave(n = wave + 3) {
      const w = W(), h = H();
      asts = [];
      const safe = { x: w / 2, y: h / 2, r: 120 };
      for (let i = 0; i < n; i++) {
        let a;
        // random position not too close to center
        do { const x = rnd(0, w), y = rnd(0, h); a = new Ast(x, y, 3); } while (Math.hypot(a.x - safe.x, a.y - safe.y) < safe.r);
        asts.push(a);
      }
      // spawn comets (one each link) per wave, optional targets that don't count toward clear
      comets = [ new CometLink('Contact Me', 'mailto:peter@storm.ac'), new CometLink('About Me', 'https://storm.ac/about.html') ];
    }

    function resetGame() { ship = new Ship(); bullets = []; parts = []; score = 0; lives = 3; wave = 1; extraAt = 10000; spawnWave(); }
    resetGame();

    function togglePause() { paused = !paused; }

    function triggerLink(url) {
      if (linkCooldown > 0) return; // debounce multiple hits
      linkCooldown = 1.2;
      try {
        if (url.startsWith('mailto:')) {
          window.location.href = url; // mail handlers prefer navigation
        } else {
          window.open(url, '_blank', 'noopener');
        }
        playBeep({ freq: 880, dur: 0.1, type: 'sine', gain: 0.2 });
      } catch (e) { /* ignore */ }
    }

    let lastTime = 0;
    function loop(ts) {
      if (!running) return;
      const dt = Math.min(0.033, (ts - lastTime) / 1000 || 0);
      lastTime = ts;
      if (!paused) { update(dt); draw(); } else { draw(); ctx.save(); ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(0, 0, W(), H()); ctx.fillStyle = '#ddd'; ctx.textAlign = 'center'; ctx.font = '16px ui-monospace, monospace'; ctx.fillText('Paused (press P)', W() / 2, H() / 2); ctx.restore(); }
      requestAnimationFrame(loop);
    }

    function update(dt) {
      linkCooldown = Math.max(0, linkCooldown - dt);
      ship.update(dt);
      if ((keys.fire || touchState.fire) && bullets.length < MAX_BULLETS) { const b = ship.fire(); if (b) bullets.push(b); }
      bullets = bullets.filter(b => (b.life > 0)); bullets.forEach(b => b.update(dt));
      asts.forEach(a => a.update(dt)); comets.forEach(c => c.update(dt));
      parts = parts.filter(p => p.life > 0); parts.forEach(p => p.update(dt));

      // bullet vs asteroids
      for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        let hit = false;
        for (let j = asts.length - 1; j >= 0; j--) {
          const a = asts[j];
          if (dist2(b, a) < (a.r + b.r) * (a.r + b.r)) {
            bullets.splice(i, 1); hit = true; asts.splice(j, 1);
            score += a.size === 3 ? 20 : a.size === 2 ? 50 : 100; explosion(); for (let k = 0; k < 16; k++) parts.push(new Particle(a.x, a.y));
            const pieces = a.split(); asts.push(...pieces);
            break;
          }
        }
        if (hit) continue;
        // bullet vs comets
        for (let j = comets.length - 1; j >= 0; j--) {
          const c = comets[j];
          if (!c.triggered && dist2(b, c) < (c.r + b.r) * (c.r + b.r)) {
            bullets.splice(i, 1); c.hit(); explosion(); for (let k = 0; k < 12; k++) parts.push(new Particle(c.x, c.y));
            break;
          }
        }
      }

      // ship vs asteroids
      if (!ship.dead) {
        const sr = ship.r * (ship.inv > 0 ? 0.6 : 1);
        for (let j = asts.length - 1; j >= 0; j--) {
          const a = asts[j];
          if (dist2(ship, a) < (a.r + sr) * (a.r + sr)) {
            ship.dead = true; ship.inv = 2.5; lives--; explosion(); for (let k = 0; k < 24; k++) parts.push(new Particle(ship.x, ship.y));
            setTimeout(() => { ship.dead = false; ship.x = W() / 2; ship.y = H() / 2; ship.vx = 0; ship.vy = 0; ship.a = -Math.PI / 2; }, 800);
            break;
          }
        }
      }

      // wave clear (comets ignored)
      if (asts.length === 0) { wave++; spawnWave(); }

      // extra life
      if (score >= extraAt) { lives++; extraAt += 10000; playBeep({ freq: 1046, dur: 0.08 }); }

      // basic game-over recycle
      if (lives < 0) { lives = 3; score = 0; wave = 1; extraAt = 10000; spawnWave(); }
    }

    function draw() {
      const w = W(), h = H();
      ctx.clearRect(0, 0, w, h);
      hud.innerHTML = `
        <span class="badge">Score: ${score}</span>
        <span class="badge">Lives: ${Math.max(0, lives)}</span>
        <span class="badge">Wave: ${wave}</span>
        <span class="badge">Sound: ${muted ? 'off' : 'on'} (M)</span>
        <span class="badge">Pause: P</span>
      `;
      parts.forEach(p => p.draw(ctx));
      asts.forEach(a => a.draw(ctx));
      comets.forEach(c => c.draw(ctx));
      // draw bullets last so they are clearly visible on top
      bullets.forEach(b => b.draw(ctx));
      if (!ship.dead) ship.draw(ctx);
    }
  })();
  </script>
</body>
</html>
